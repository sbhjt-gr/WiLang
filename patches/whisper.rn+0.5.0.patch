diff --git a/node_modules/whisper.rn/cpp/jsi/RNWhisperJSI.cpp b/node_modules/whisper.rn/cpp/jsi/RNWhisperJSI.cpp
index 1234567..abcdefg 100644
--- a/node_modules/whisper.rn/cpp/jsi/RNWhisperJSI.cpp
+++ b/node_modules/whisper.rn/cpp/jsi/RNWhisperJSI.cpp
@@ -99,6 +99,9 @@ public:
 static ContextManager<whisper_context> contextManager("Whisper");
 static ContextManager<whisper_vad_context> vadContextManager("VAD");

+static std::unordered_map<int, std::shared_ptr<std::mutex>> vadMutexMap;
+static std::mutex vadMutexMapLock;
+
 // Context management functions
 void addContext(int contextId, long contextPtr) {
     contextManager.add(contextId, contextPtr);
@@ -110,10 +113,20 @@ void removeContext(int contextId) {

 void addVadContext(int contextId, long vadContextPtr) {
     vadContextManager.add(contextId, vadContextPtr);
+    {
+        std::lock_guard<std::mutex> lock(vadMutexMapLock);
+        vadMutexMap[contextId] = std::make_shared<std::mutex>();
+    }
 }

 void removeVadContext(int contextId) {
     vadContextManager.remove(contextId);
+    {
+        std::lock_guard<std::mutex> lock(vadMutexMapLock);
+        vadMutexMap.erase(contextId);
+    }
 }

 long getContextPtr(int contextId) {
@@ -615,6 +628,24 @@ void installJSIBindings(
                                 return;
                             }

+                            std::shared_ptr<std::mutex> vadMutex;
+                            {
+                                std::lock_guard<std::mutex> lock(vadMutexMapLock);
+                                auto it = vadMutexMap.find(contextId);
+                                if (it != vadMutexMap.end()) {
+                                    vadMutex = it->second;
+                                }
+                            }
+
+                            if (!vadMutex) {
+                                callInvoker->invokeAsync([rejectPtr, safeRuntime, contextId]() {
+                                    auto& runtime = *safeRuntime;
+                                    auto errorObj = createErrorObject(runtime, "VAD mutex not found for id: " + std::to_string(contextId));
+                                    rejectPtr->call(runtime, errorObj);
+                                });
+                                return;
+                            }
+
+                            std::lock_guard<std::mutex> vadLock(*vadMutex);
+
-                            // Validate audio data
                             if (audioResult.data.empty() || audioResult.count <= 0) {
                                 logError("Invalid audio data: size=%zu, count=%d", audioResult.data.size(), audioResult.count);
                                 callInvoker->invokeAsync([rejectPtr, safeRuntime]() {
@@ -627,7 +658,6 @@ void installJSIBindings(
                             logInfo("Starting whisper_vad_detect_speech: vadContext=%p, audioDataCount=%d",
                                    vadContext, audioResult.count);

-                            // Perform VAD detection with error handling
                             bool isSpeech = false;
                             try {
                                 isSpeech = whisper_vad_detect_speech(vadContext, audioResult.data.data(), audioResult.count);
